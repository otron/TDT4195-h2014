aw yes poof bam slam damn jam get up and down with the flow and the hoe cut that grass get that grain make some bread to feed your brain
//ain't nothing but a thug lyfe//

Let's start by reading through the presentation to get an idea of what the lab is about.
Then I'll see if the answer is available in one of the tutorials on opengl-tutorial.org.

First up it talks about back face culling and z-depth.
It even uses the same cube as tutorial 4 to illustrate what happens when GL_DEPTH_TEST is disabled, which it is by default.
There's got to exist some library out there that is more suited for this teaching purpose than OpenGL, considering the purpose isn't to learn OpenGL but rather to see how the theoretical principles we've learned are implemented.
OpenGL has a lot of overhead which isn't relevant to that at all.
It takes me longer to figure out how I'm supposed to do something in OpenGL and the enclosing C++ or GLSL than figuring out which transformations or operations or things I want to do.

Next up is Mouse Handling.
glutMouseFunc(arg) -> arg becomes the mouse callback for the current window.
Each press and each release generates a mouse callback.

glutMotionFunc(arg) -> arg becomes the callback that handles mouse motion while buttons are being pressed.
Wait, so it's only called if the mouse is moved WHILE a mouse button is pressed down?
I'm gonna download the project and compile it and see what happens.
It runs without issue. Scene 1-4 contains a cube. Back face culling happens in RS2-4, but not in 1.
Switching from 2 or 3 to 1 displays the cube in 1 without BFC, but changing from scene 4 to 1 causes it to be rendered *with* BFC. Strange.

Also yeah, the glutMotionFunc thing only reacts while a mouse button is pressed down.
The callbacks are actually defined in visuals.cpp, and aren't just some builtin magic bullshit.
I feel like mentioning that would clear up a great deal of confusion, but then again I could just look for it myself by oh I don't know running grep -rinH . "whatever" and see what turns up.

Next up in the presentation is "Hierarchical modeling".
Several objects all a part of one model or another object or whatever in a hierarchical tree-like structure where transformations applied to a member is applied to its children as well and with respect to the parent's CS.

"keyboard special keys such as Fx or Up, Down, etc"
That doesn't tell me much. Like, what are the non-special keys? Is space a regular key? What about return?

How are mouse_x and y used to animate the scenes 3-5? All they're used for is calculating where to move the camera. Is camera movement considered a part of the animation?

BFC is explicitly disabled in RS3, while the depth test is not.
RS4 enables both the depth test and BFC.
So that's why RS1 looks correct after rendering RS4 -- the only way to re-disable BFC is by loading RS3.

The thing in RS5's speed is proportional to how long the scene has been active.

First up I have to rotate the hip joints like the legs.
Time to look for some tutorials.
Nope, this one isn't lifted straight from opengl-tutorials.org.
Hmmm.

# Rotate them hip joints son
Can I just copy the code for the legs and do the exact same thing with the hip joints?
Or am I supposed to apply the rotation to the hip joints instead, which'll cause the legs to move because the legs are children of the hips?

"HIP" is the paralleliped that connects the hip joints.
Hip joint 1 and 2 are the cubes on the intersection of HIP and LEG 1 and 2.
How is the hierarchy defined in the code?
Okay they just add the MODEL_EVERYTHING matrix into the mix (definition of MVP).
To make the HJ rotate I could apply the rotation transformation to the HIP JOINTS instead and define the MVP for legs as
Projection * View * MODEL_EVERYTHING * MODEL_HJ_n * MODEL_LEG_n * Model

I'll try defining MODEL_HJ_1 and 2 just like what they've done with MODEL_LEG_1 and 2 and see if it works
Right I have to declare them in the header file as well? Ungh.
Nope! Just had a typo.
And that didn't work.

Oh, forgot to add the models to the hip joint MVPs.
The hip joints and legs are rotating in the opposite direction now.
That's weird.

Oh it's because you guys have hooked LEG_1 to HIP JOINT 2 and LEG_2 to HIP JOINT 1.
Way to go!
Swapped the translation definitions for HJ1 and 2 -- i.e. multiplied the vector by -1 or whatever. It works now.


